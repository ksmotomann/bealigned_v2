// Chat welcome prompts organized by tone and approach
export const WELCOME_PROMPTS = {
  reflective: [
    "Being here isn't about having all the answers. It's about quieting the noise long enough to see what's really underneath. What's on your mind today?",
    "Sometimes the hardest part is slowing down enough to notice what matters. What's asking for your attention today?",
    "This is your pause button. What's the noise you most want to quiet?"
  ],
  
  validating: [
    "Some days feel like too much. What's the one thing weighing most on you right now?",
    "You showed upâ€”that's already progress. Where do you want to start from here?",
    "I'm not here to hand you answers. I'm here to help you uncover the ones already within you. Where should we start?",
    "You made it hereâ€”that's something. What do you want to work through first?"
  ],
  
  sorting: [
    "You don't need to fix everything at once. What's the first piece you'd like to sort through?",
    "This space isn't about judgmentâ€”it's about finding clarity in the middle of the mess. What's showing up for you right now?",
    "Carrying a heavy load today? What can you set down here?",
    "You've got a lot on your plate. What's one piece we can clear off together?"
  ],
  
  direct: [
    "Have at me. Bring the mess, the questions, the weight of it allâ€”this is where we make it lighter. What do you want to lay down first?",
    "Lay it on me. What do you want to get off your chest first?",
    "Hit me with it. What's taking up the most space in your head right now?",
    "Go aheadâ€”get it out. What's the thing you want to let go of the most?",
    "Don't hold back. What's the first thing you need to say?",
    "Bring it. Big or smallâ€”what's on you that we can unpack here?"
  ]
}

// Get all prompts as a flat array
const ALL_PROMPTS = [
  ...WELCOME_PROMPTS.reflective,
  ...WELCOME_PROMPTS.validating,
  ...WELCOME_PROMPTS.sorting,
  ...WELCOME_PROMPTS.direct
]

// Get a random welcome prompt (legacy function for backwards compatibility)
export function getRandomWelcomePrompt(): string {
  const randomIndex = Math.floor(Math.random() * ALL_PROMPTS.length)
  return ALL_PROMPTS[randomIndex]
}

// New AI-powered welcome message (async) with timeout
export async function getAIGeneratedWelcome(userProfile?: any): Promise<string> {
  console.log('ðŸŽ¯ === BeH2O ENHANCED WELCOME GENERATION START ===')
  console.log('ðŸŽ¯ Attempting AI welcome with BeH2O methodology integration...')

  // Create a timeout promise that rejects after 15 seconds (increased for vector lookup + AI generation)
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error('BeH2O AI welcome generation timeout')), 15000)
  })

  try {
    console.log('ðŸš€ Calling generate-ai-welcome edge function directly...')

    // Import supabase client (same pattern as working edge functions)
    const { supabase } = await import('./supabase')
    console.log('âœ… Supabase client imported successfully')

    // Build simple user profile
    const profile = userProfile || {
      preferredTone: 'validating',
      communicationStyle: 'supportive',
      timeOfDay: 'unknown'
    }
    console.log('ðŸ‘¤ User profile for BeH2O welcome:', profile)

    console.log('ðŸ“ž Invoking edge function with 5 second timeout...')

    // Get auth token for the function call
    const { data: { session } } = await supabase.auth.getSession()

    // Race between AI generation and timeout
    const aiMessage = await Promise.race([
      supabase.functions.invoke('generate-ai-welcome', {
        body: { userProfile: profile },
        headers: session?.access_token ? {
          'Authorization': `Bearer ${session.access_token}`
        } : {}
      }),
      timeoutPromise
    ])

    console.log('ðŸ” Edge function response:', aiMessage)
    console.log('ðŸ” Response error:', aiMessage.error)
    console.log('ðŸ” Response data:', aiMessage.data)

    if (aiMessage.error) {
      console.error('âŒ Edge function returned error:', aiMessage.error)
      throw new Error(`Edge Function failed: ${aiMessage.error.message}`)
    }

    if (!aiMessage.data?.welcomeMessage) {
      console.error('âŒ No welcome message in response data:', aiMessage.data)
      throw new Error('No welcome message returned from Edge Function')
    }

    const welcomeText = aiMessage.data.welcomeMessage
    const responseType = aiMessage.data.responseType || 'ai_vector'
    const generatedBy = aiMessage.data.generatedBy || 'unknown'

    console.log('âœ… BeH2O-enhanced AI welcome message generated:', welcomeText)
    console.log('ðŸŽ¯ Response type:', responseType)
    console.log('ðŸŽ¯ Generated by:', generatedBy)
    console.log('ðŸŽ¯ Message length:', welcomeText.length, 'characters')
    console.log('ðŸŽ¯ First 100 chars:', welcomeText.substring(0, 100))

    // Force correct detection if it's actually a static fallback
    if (generatedBy === 'static') {
      console.warn('âš ï¸ Welcome function returned static fallback, throwing error to trigger local fallback')
      throw new Error('Welcome function returned static fallback')
    }

    console.log('ðŸŽ¯ === BeH2O ENHANCED WELCOME GENERATION SUCCESS ===')
    return welcomeText
  } catch (error) {
    console.warn('âš ï¸ BeH2O AI welcome generation failed, using rich static fallback:', error)
    console.error('ðŸ” Error details:', error)
    console.log('ðŸ’¡ Falling back to rich welcome prompts from vector database examples...')

    try {
      const fallback = getRandomWelcomePrompt()
      console.log('ðŸ“ Rich static fallback message:', fallback)
      console.log('ðŸ“ Fallback type:', typeof fallback)
      console.log('ðŸ“ Fallback length:', fallback?.length)
      console.log('ðŸŽ¯ === BeH2O WELCOME GENERATION FALLBACK ===')
      return fallback
    } catch (fallbackError) {
      console.error('âŒ Even static fallback failed:', fallbackError)
      console.log('ðŸ†˜ Returning emergency fallback message')
      return "Let's take a moment to explore what's on your mind. What situation would you like to reflect on?"
    }
  }
}

// Get a random prompt from a specific category
export function getRandomWelcomePromptByCategory(category: keyof typeof WELCOME_PROMPTS): string {
  const categoryPrompts = WELCOME_PROMPTS[category]
  const randomIndex = Math.floor(Math.random() * categoryPrompts.length)
  return categoryPrompts[randomIndex]
}

// Get a weighted random prompt (can adjust weights based on user preferences)
export function getWeightedRandomWelcomePrompt(weights?: {
  reflective?: number
  validating?: number
  sorting?: number
  direct?: number
}): string {
  const defaultWeights = { reflective: 1, validating: 1, sorting: 1, direct: 1 }
  const finalWeights = { ...defaultWeights, ...weights }
  
  // Create weighted array
  const weightedPrompts: string[] = []
  
  Object.entries(WELCOME_PROMPTS).forEach(([category, prompts]) => {
    const weight = finalWeights[category as keyof typeof finalWeights] || 1
    for (let i = 0; i < weight; i++) {
      weightedPrompts.push(...prompts)
    }
  })
  
  const randomIndex = Math.floor(Math.random() * weightedPrompts.length)
  return weightedPrompts[randomIndex]
}

// Future enhancement: Get prompt based on user personality/bio profile
export function getPersonalizedWelcomePrompt(userProfile?: {
  personality?: 'reflective' | 'direct' | 'validating' | 'sorting'
  communicationStyle?: 'gentle' | 'direct' | 'supportive' | 'structured'
}): string {
  if (!userProfile?.personality) {
    return getRandomWelcomePrompt()
  }
  
  // Map personality types to tone categories
  const personalityToCategory: Record<string, keyof typeof WELCOME_PROMPTS> = {
    reflective: 'reflective',
    direct: 'direct', 
    validating: 'validating',
    sorting: 'sorting'
  }
  
  const category = personalityToCategory[userProfile.personality]
  return category ? getRandomWelcomePromptByCategory(category) : getRandomWelcomePrompt()
}